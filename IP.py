# IOE 691 Project
# Integer programming for DVRP on tree metrics
# Implemented by Gurobi
# @Author: Guixian Chen, gxchen@umich.edu
#
from minTVR import *
from gurobipy import Model, GRB
from tqdm import tqdm


# Generate all subtrees containing root
# Input:
# nodes: generated by function "build_tree"
# D: parameter of capacity constraint
# Output:
# useful_subtrees_with_root: list of "useful" subtrees with edge weights
#
def generate_subtrees_with_root(nodes, D):
    # Classifying nodes into different levels
    nodes_level = {}
    for node_id in nodes.keys():
        node = nodes[node_id]
        node_level = node.level
        if node_level not in nodes_level.keys():
            nodes_level[node_level] = [node_id]
        else:
            nodes_level[node_level].append(node_id)

    # Compute the maximum level of tree
    tree_max_level = max(nodes_level.keys())

    # BFS: generate all subtrees containing root
    # Initialize with empty subtree containing only root
    subtrees_with_root = [([1], 0, [1])]
    for level in tqdm(range(1, tree_max_level+1)):
        for node_id in nodes_level[level]:
            node = nodes[node_id]
            node_parent = node.parent.id
            wt = node.edge_weight
            for subtree in subtrees_with_root:
                if (node_parent not in subtree[0]) or (node_id in subtree[0]):
                    continue
                new_subtree_wt = subtree[1] + wt
                # Discard subtree if violating capacity constraint
                if new_subtree_wt > D/2:
                    continue
                subtree[2][0] = 0  # record this subtree as "useless"
                new_subtree_lis = subtree[0] + [node_id]
                subtrees_with_root.append((new_subtree_lis, new_subtree_wt, [1]))
    
    # Only keep "useful" subtrees
    useful_subtrees_with_root = []
    for subtree in subtrees_with_root:
        if subtree[2] == [1]:
            useful_subtrees_with_root.append(subtree[:2])
    return useful_subtrees_with_root


# Solving IP for DVRP
# Input:
# nodes: generated by function "build_tree"
# D: parameter of capacity constraint
# Output:
# sol_set: selected subtrees of optimal solution
#
def IP_DVRP(nodes, D):
    # Generate all subtrees with root
    subtrees_with_root = generate_subtrees_with_root(nodes, D)

    # For each node, find all subtrees that cover it
    nodes_cover = {key: [] for key in nodes}
    n = len(subtrees_with_root)  # number of subtrees (variables)
    for i in range(n):
        subtree = subtrees_with_root[i]
        subtree_nodes = subtree[0]
        for node in subtree_nodes:
            nodes_cover[node].append(i)
    
    # Create a model
    model = Model("IP for DVRP")
    # Add variables
    random_vars = {}
    for i in range(n):
        random_vars[i] = model.addVar(lb=0, ub=1, vtype=GRB.INTEGER, name=f"x_{i}")
    
    # Add constraints
    for node in nodes_cover:
        model.addConstr(sum(random_vars[i] for i in nodes_cover[node]) >= 1)
    
    # Set objective
    model.setObjective(sum(random_vars[i] for i in range(n)), GRB.MINIMIZE)
    
    # Optimize
    print("Start optimizing IP...")
    model.optimize()

    # Output
    sol_set = []
    for i in range(n):
        if random_vars[i].X == 1:
            sol_set.append(subtrees_with_root[i])
    
    return sol_set
    
